var documenterSearchIndex = {"docs":
[{"location":"examples/Unwrapping/#Phase-Unwrapping","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"","category":"section"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"We will use the calculated response function for the phase unwrapping demonstration.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")\nmask = circlemask((300, 300), 150, 150, 145)\nact = circlemask((300, 300), 50, 153.5, 10)\nresp = membrane_sor(act, mask);\nnothing #hide","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"First, we define a couple of plotting functions to save on typing","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"phasedisplay(args...; kwargs...) = heatmap(\n    args...;\n    axis=(aspect=DataAspect(),),\n    colormap=:cyclic_mygbm_30_95_c78_n256,\n    kwargs...,\n)\narraydisplay(args...; kwargs...) = heatmap(args...; axis=(aspect=DataAspect(),), kwargs...)\n\nresp ./= 10\narraydisplay(resp)\n\nresp_wr = phwrap(resp)\nphasedisplay(resp_wr)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"This noiseless, periodic, and defined on the whole domain phase is easy to unwrap by line-by-line integration of wrapped phase differences using the Itoh algorithm, see itoh.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"ph_itoh = reshape(itoh(resp_wr[:]), size(resp_wr))\narraydisplay(ph_itoh)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Phases occurring in real life are usually a little bit more complicated. Below are two simple illustrations.","category":"page"},{"location":"examples/Unwrapping/#Finite-region-with-non-zero-boundary","page":"Phase Unwrapping","title":"Finite region with non-zero boundary","text":"","category":"section"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"First of all, they are often defined only in some region Ω, and do not zero out on the boundary of the region Ω`. This is simulated below by adding some linear tilt to the phase.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"tilt = [(i[1] * 0.000135 + i[2] * 0.0011 + 10) for i in eachindex(IndexCartesian(), mask)]\nresp_wr = phwrap((resp .+ tilt)) .* mask\nphasedisplay(resp_wr .* ap2mask(mask))","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"(here we have used ap2mask function which removes the pixels outside the mask for better visibility).","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Here is what happens if we subtract the (exactly known) tilt from our new wrapped phase","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"phasedisplay((resp_wr .- tilt) .* ap2mask(mask))\nphasedisplay(resp_wr .* ap2mask(mask))","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"This phase should not be restorable by the Itoh algorithm because the jumps on the boundary are greater than π, and indeed we see the errors in unwrapping","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"ph_itoh = reshape(itoh(resp_wr[:]), size(resp_wr))\narraydisplay((ph_itoh .- tilt) .* mask)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"but wrapped back it looks OK, of course (what we see is just unwrapping errors, assigning wrong k to an unwrapped value hatphi = psi + 2πk k  mathbbZ):","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"phasedisplay(phwrap(ph_itoh .- tilt) .* ap2mask(mask))","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"We can unwrap it with the least-squares algorithm","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"phi_LS = unwrap_LS(resp_wr, mask)\narraydisplay((phi_LS .- tilt) .* ap2mask(mask))","category":"page"},{"location":"examples/Unwrapping/#Small-noise","page":"Phase Unwrapping","title":"Small noise","text":"","category":"section"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"The straightforward unwrapping becomes impossible if value of one pixel has jumped to approximately on π radians (for instance, due to a broken pixel). You can hardly see the difference (check pixel (100,100)).","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"addpi!(arr, r, c) = (arr[r, c] = phwrap(arr[r, c] + π))\n\nresp_wr = phwrap(resp)\naddpi!(resp_wr, 100, 100)\nphasedisplay(resp_wr .* ap2mask(mask))","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Try to unwrap it:","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"ph_itoh = reshape(itoh(resp_wr[:]), size(resp_wr))\narraydisplay((ph_itoh) .* mask)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"and we see that one pixel made the unwrapping impossible, because a spurious phase jump on 2π appeared on passing the broken pixel. But we can unwrap it with the least-squares algorithm:","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"resp_LS = unwrap_LS(resp_wr, mask; restore_piston=true)\nfig, ax, hm = arraydisplay(resp_LS);\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/#Example-with-wedge-(with-zero-mean-for-simplicity-of-comparison-with-the-restored)","page":"Phase Unwrapping","title":"Example with wedge (with zero mean for simplicity of comparison with the restored)","text":"","category":"section"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge = mask .* linearphase((300, 300), 150, 150, 0.2, 0.11)\npiston = maskedrmse(wedge, mask)\nwedge .-= piston\nfig, ax, hm = arraydisplay(wedge)\nColorbar(fig[1, 2], hm)\nax.title = \"Original wedge\"\nfig\n\nwedge_wr = phwrap(wedge)\nphasedisplay(wedge_wr)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"It's impossible to unwrap it with the Itoh algorithm.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_itoh = reshape(itoh(wedge_wr[:]), size(wedge_wr))\nfig, ax, hm = arraydisplay(wedge_itoh)\nColorbar(fig[1, 2], hm)\nax.title = \"RMS error is $(maskedrmse(wedge_itoh, wedge, mask))\"\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Nor it's possible to do this using Itoh's algorithm along the rows.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_itoh = reshape(itoh(wedge_wr'[:]), size(wedge_wr))'\nfig, ax, hm = arraydisplay(wedge_itoh)\nColorbar(fig[1, 2], hm)\nax.title = \"RMS error is $(maskedrmse(wedge_itoh, wedge, mask))\"\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"But we can unwrap it with the least-squares algorithm (up to an integer multiple of 2π, which we calculate here as the value of the error at the central pixel)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_LS = unwrap_LS(wedge_wr, mask; restore_piston=false)\npiston = wedge_LS[150, 150] - wedge[150, 150]\nwedge_LS .-= piston\nfig, ax, hm = arraydisplay(wedge_LS);\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Compare with the original wedge:","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"fig, ax, hm = arraydisplay((wedge_LS .- wedge))\nColorbar(fig[1, 2], hm)\nax.title = \"RMS error is $(maskedrmse(wedge_LS, wedge, mask))\"\nfig","category":"page"},{"location":"examples/Unwrapping/#Unwrapping-of-the-phase-with-residues","page":"Phase Unwrapping","title":"Unwrapping of the phase with residues","text":"","category":"section"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Let us add some bad pixel groups to the wrapped wedge","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"resblock!(arr, r, c) = (arr[c:(c + 1), r:(r + 1)] .= [0 π/2; -π/2 π])\nresblock!(wedge_wr, 100, 110)\nresblock!(wedge_wr, 50, 150)\nresblock!(wedge_wr, 130, 130)","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"And add 1 π to some pixels","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"addpi!(wedge_wr, 200, 200)\naddpi!(wedge_wr, 40, 180)\n\nfig, ax, hm = phasedisplay(wedge_wr)\nax.title = \"RMS error with the original phase is $(maskedrmse(wedge_wr, phwrap(wedge), mask))\"\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"It's still impossible to unwrap it with the Itoh algorithm, but now the error is of a different type","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_itoh = reshape(itoh(wedge_wr[:]), size(wedge_wr))\nfig, ax, hm = arraydisplay(wedge_itoh)\nax.title = \"RMS error is $(maskedrmse(wedge_itoh, wedge, mask))\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Nor it's possible to do this using Itoh's algorithm along the rows.","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_itoh = reshape(itoh(wedge_wr'[:]), size(wedge_wr))'\nfig, ax, hm = arraydisplay(wedge_itoh)\nax.title = \"RMS error is $(maskedrmse(wedge_itoh, wedge, mask))\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"But we can unwrap it with the least-squares algorithm","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"wedge_LS = unwrap_LS(wedge_wr, mask; restore_piston=true)\nwedge_LS .-= piston\nfig, ax, hm = arraydisplay(wedge_LS)\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"Compare with the original wedge:","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"fig, ax, hm = arraydisplay(ap2mask(mask) .* (wedge_LS .- wedge))\nax.title = \"RMS error is $(maskedrmse(wedge_LS, wedge, mask))\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"","category":"page"},{"location":"examples/Unwrapping/","page":"Phase Unwrapping","title":"Phase Unwrapping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API-Reference-{#api}","page":"API","title":"API Reference {#api}","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 2","category":"page"},{"location":"api/#PhaseUtils.ArrayAxes","page":"API","title":"PhaseUtils.ArrayAxes","text":"ArrayAxes\n\nAbstract supertype for axis policies that produce coordinate vectors for each dimension of an array. Policies are callable: axes = policy(dims) returns a vector of per-dimension coordinate vectors. These coordinates define the domain on which tilts are evaluated or materialized.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.DataAxes","page":"API","title":"PhaseUtils.DataAxes","text":"DataAxes <: ArrayAxes\n\nAxis policy that returns 1-based data indices for each dimension: 1:d. Useful when slopes are defined with respect to array indices (pixel grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.DataAxes-Tuple{Tuple{Vararg{T, N}} where {N, T}}","page":"API","title":"PhaseUtils.DataAxes","text":"(alg::DataAxes)(dims::NTuple)\n\nReturn 1-based index coordinate vectors 1:d for each dimension in dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.DataAxesCentered","page":"API","title":"PhaseUtils.DataAxesCentered","text":"DataAxesCentered <: ArrayAxes\n\nAxis policy that returns centered data coordinates per dimension using fftshift(fftfreq(d, d)), i.e., integer-like coordinates centered at zero. This is convenient for spatial-domain operations centered on the array.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.DataAxesCentered-Tuple{Tuple{Vararg{T, N}} where {N, T}}","page":"API","title":"PhaseUtils.DataAxesCentered","text":"(alg::DataAxesCentered)(dims::NTuple)\n\nReturn centered integer-like coordinates for each dimension using fftshift(fftfreq(d, d)).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.FourierAxes","page":"API","title":"PhaseUtils.FourierAxes","text":"FourierAxes <: ArrayAxes\n\nAxis policy that returns Fourier-domain coordinates for each dimension: fftshift(fftfreq(d)). Useful for representing slopes in normalized frequency units aligned with FFT conventions.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.FourierAxes-Tuple{Tuple{Vararg{T, N}} where {N, T}}","page":"API","title":"PhaseUtils.FourierAxes","text":"(alg::FourierAxes)(dims::NTuple)\n\nReturn Fourier-domain coordinate vectors for each dimension in dims using fftshift(fftfreq(d)).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.FreeTilt","page":"API","title":"PhaseUtils.FreeTilt","text":"FreeTilt{N} <: Tilt\n\nConcrete tilt with the same storage layout as TiltCentered, but without implied centering semantics. Use this when you want an unconstrained tilt parameterization in arbitrary coordinates.\n\nConstruction: FreeTilt(coefs::AbstractVector) converts the input to a static vector for performance.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.ProvidedAxes","page":"API","title":"PhaseUtils.ProvidedAxes","text":"ProvidedAxes <: ArrayAxes\n\nAxis policy that wraps explicitly provided coordinate vectors. Use when you already have precomputed (possibly non-uniform) axes and want to reuse the same policy interface.\n\nConstruction:     ProvidedAxes(ax1, ax2, ...) Each axis must be an AbstractVector. The policy is callable:     ProvidedAxes(ax1, ax2)(dims) -> Vector of the stored axes (validates dims). If dims do not match the stored axes lengths, an ArgumentError is thrown.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.Tilt","page":"API","title":"PhaseUtils.Tilt","text":"Tilt\n\nAbstract supertype for affine tilt parameterizations used across imaging and Fourier-domain modules.\n\nTilts are represented by a fixed-length coefficient vector coefs with the layout [σ, τ₁, τ₂, …], where σ is the constant (piston) term, and τ is the slope vector in the chosen coordinate system. The coordinate system is provided by an axis policy (see ArrayAxes and its subtypes).\n\nConcrete subtypes must store a field coefs and are expected to work with the helpers sigma, tau, setsigma!, settau!, setall!, apply, and materialize defined in this module.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.TiltCentered","page":"API","title":"PhaseUtils.TiltCentered","text":"TiltCentered{N} <: Tilt\n\nConcrete tilt storing coefficients in a static vector coefs::MVector{N,Float64} with layout [σ, τ₁, τ₂, …]. This is convenient when the tilt is anchored to a coordinate frame centered at the origin (e.g., frequency coordinates).\n\nConstruction: TiltCentered(coefs::AbstractVector) converts the input to a static vector for performance.\n\n\n\n\n\n","category":"type"},{"location":"api/#PhaseUtils.ap2mask-Tuple{Any}","page":"API","title":"PhaseUtils.ap2mask","text":"ap2mask(ap)\n\nConverts  ap array to mask, so that every zero is mapped to NaN and non-zero elements to 1.\n\nSee also mask2ap.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.bboxview","page":"API","title":"PhaseUtils.bboxview","text":"bboxview(arr, mask, pad = 0)\n\nMake a box corresponding to the mask not-NaN elements surrounded by pad.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhaseUtils.binarize-Tuple{Any}","page":"API","title":"PhaseUtils.binarize","text":"binarize(ap)\n\nConverts  ap array to a binary array b, so that every zero or NaN is mapped to 0 and non-zero elements to 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask!-Tuple{Matrix{<:Number}, Any, Any, Any, ArrayAxes}","page":"API","title":"PhaseUtils.circlemask!","text":"circlemask!(a::Matrix{<:Number}, cx, cy, r, policy::ArrayAxes)\n\nZero elements of a outside the circle centered at (cx, cy) with radius r using coordinates from policy(size(a)).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask!-Tuple{Matrix{<:Number}, Any, Any, Any}","page":"API","title":"PhaseUtils.circlemask!","text":"circlemask!(a::Matrix{<:Number}, [cx, cy,] r)\n\nSet to zero values of matrix a outside the circle with center (cx,cy) and radius r.\n\nIf omitted, (cx,cy) is the center of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask!-Tuple{Matrix{<:Number}, Any, ArrayAxes}","page":"API","title":"PhaseUtils.circlemask!","text":"circlemask!(a::Matrix{<:Number}, r, policy::ArrayAxes)\n\nZero elements of a outside the circle of radius r using coordinates from policy(size(a)). The circle is centered at 0 if that value exists in each axis; otherwise at the middle coordinate value.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask!-Union{Tuple{T}, Tuple{Matrix{<:Number}, Vector{T}, Any, Any, Any}} where T<:(AbstractVector)","page":"API","title":"PhaseUtils.circlemask!","text":"circlemask!(a::Matrix{<:Number}, axes::Vector{<:AbstractVector}, cx, cy, r)\n\nZero elements of a outside the circle centered at (cx, cy) with radius r evaluated on explicit axes (one vector per dimension). The length of each axis must match the corresponding dimension of a.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask-Tuple{Tuple{Int64, Int64}, Any, Any, Any, ArrayAxes}","page":"API","title":"PhaseUtils.circlemask","text":"circlemask(dims::NTuple{2,Int}, cx, cy, r, policy::ArrayAxes)\n\nCreate a boolean mask of size dims using coordinates from policy, with a circle centered at (cx, cy) in those coordinate units and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask-Tuple{Tuple{Int64, Int64}, Any, ArrayAxes}","page":"API","title":"PhaseUtils.circlemask","text":"circlemask(dims::NTuple{2,Int}, r, policy::ArrayAxes)\n\nCreate a boolean mask of size dims using coordinates provided by policy. The circle is centered at the default origin of those coordinates (zero if present; otherwise the middle coordinate value) with radius r expressed in the same coordinate units.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask-Tuple{Tuple{Int64, Int64}, Vararg{Any}}","page":"API","title":"PhaseUtils.circlemask","text":"circlemask(dims::NTuple{2, Int}, cx, cy, r)\n\nCreate a boolean matrix of size dims with true only inside the circle with center (cx,cy) and radius r.\n\nIf omitted, (cx,cy) is the center of the domain: (dims+1)/2.\n\nExamples\n\njulia> circlemask((6,8), 2.5,3, 1.5)\n6×8 Matrix{Bool}:\n 0  0  1  0  0  0  0  0\n 0  1  1  1  0  0  0  0\n 0  1  1  1  0  0  0  0\n 0  0  1  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n\njulia> circlemask((10,10), 3)\n10×10 Matrix{Bool}:\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  1  1  1  1  0  0  0\n 0  0  1  1  1  1  1  1  0  0\n 0  0  1  1  1  1  1  1  0  0\n 0  0  1  1  1  1  1  1  0  0\n 0  0  1  1  1  1  1  1  0  0\n 0  0  0  1  1  1  1  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.circlemask-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Any}} where T<:(AbstractVector)","page":"API","title":"PhaseUtils.circlemask","text":"circlemask(axes::Vector{<:AbstractVector}, cx, cy, r)\n\nCreate a boolean mask evaluated on explicit coordinate axes (one vector per dimension), marking points inside the circle of center (cx, cy) and radius r.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.crop-Tuple{AbstractArray, Any, Any}","page":"API","title":"PhaseUtils.crop","text":"crop(a::AbstractArray, cropsize[, cropcenter])\ncrop(cropsize[, cropcenter]) creates a cropping operator.\n\nCrop the array to cropsize around cropcenter. If cropcenter is omitted, use central element of the array.\n\ncropsize and cropcenter can be either tuples/vectors of integers or just single integer, which represent a tuple of identical numbers.\n\nExamples\n\njulia> a = reshape(1:15, 3, 5); crop(a, 1, (1, 3))\n1×1 Matrix{Int64}:\n 7\n\njulia> crop(a, (2, 2), (1, 3))\n1×2 Matrix{Int64}:\n 4  7\n\njulia> crop(3)(a)\n3×3 Matrix{Int64}:\n 4  7  10\n 5  8  11\n 6  9  12\n\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.getresmap-Tuple{Any, Any}","page":"API","title":"PhaseUtils.getresmap","text":"getresmap(gx, gy) -> resmap\n\nFind residues in the phase, which correspond to the residues in the wrapped phase gradients expressed in 2pi multiples.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.getresmap-Tuple{Any}","page":"API","title":"PhaseUtils.getresmap","text":"getresmap(phase) -> resmap\n\nFind residues in the phase, which correspond to the residues in the wrapped phase gradients expressed in 2pi multiples.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.getresmapsparce-Tuple{Any, Any}","page":"API","title":"PhaseUtils.getresmapsparce","text":"getresmapsparce(gx,gy) -> posx, posy, resmap\n\nFind residues in the (inconsistent) gradient field.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.getresmapsparce-Tuple{Any}","page":"API","title":"PhaseUtils.getresmapsparce","text":"getresmapsparce(phase) -> posx, posy, resmap\n\nFind residues in the phase, which correspond to the residues in the wrapped phase gradients expressed in 2pi multiples.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.integrate_2dgrad-Tuple{Any, Any, PhaseUtils.LeastSquares}","page":"API","title":"PhaseUtils.integrate_2dgrad","text":"integrate_2dgrad(gx, gy[, gradmethod=default_grad_method(gx)])\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.integrate_periodic_grad-Tuple{Any}","page":"API","title":"PhaseUtils.integrate_periodic_grad","text":"integrate_periodic_grad(g)\n\nIntegrate 1D gradient with periodic boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.itoh-Tuple{Any}","page":"API","title":"PhaseUtils.itoh","text":"itoh(phi)\n\nItoh's algorithm for 1D phase unwrapping.\n\nExample\n\njulia> ph = 1:10\n1:10\n\njulia> ph_w = phwrap(ph)\n10-element Vector{Float64}:\n  1.0\n  2.0\n  3.0\n -2.2831853071795867\n -1.2831853071795865\n -0.28318530717958645\n  0.7168146928204135\n  1.7168146928204135\n  2.7168146928204133\n -2.566370614359173\n\njulia> itoh(ph_w)\n10-element Vector{Float64}:\n  1.0\n  2.0\n  3.0\n  4.0\n  5.0\n  6.0\n  7.0\n  8.0\n  9.0\n 10.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.linearphase","page":"API","title":"PhaseUtils.linearphase","text":"linearphase(dims::NTuple{2,Int}, t::Tilt, policy::ArrayAxes=FourierAxes())\n\nCreate a matrix by evaluating the tilt t on coordinates given by policy(dims). This is equivalent to materialize(t, policy(dims)).\n\n\n\n\n\n","category":"function"},{"location":"api/#PhaseUtils.linearphase-2","page":"API","title":"PhaseUtils.linearphase","text":"linearphase(T::Type{<:Number}, dims::NTuple{2,Int}, t::Tilt, policy::ArrayAxes=FourierAxes())\n\nTyped variant of linearphase(dims, t, policy) converting the result to T.\n\n\n\n\n\n","category":"function"},{"location":"api/#PhaseUtils.linearphase-Tuple{Type{<:Number}, Tuple{Int64, Int64}, Vararg{Any, 4}}","page":"API","title":"PhaseUtils.linearphase","text":"linearphase(T=Float64, dims::NTuple{2,Int},  cx, cy, kx, ky)\n\nCreate a matrix with linear phase with slopes (kx, ky) and having zero at point (cx, cy).\n\nExample\n\njulia> linearphase((5,7), 3, 3, 1.5, 1.5)\n5×7 Matrix{Float64}:\n -6.0  -4.5  -3.0  -1.5  0.0  1.5  3.0\n -4.5  -3.0  -1.5   0.0  1.5  3.0  4.5\n -3.0  -1.5   0.0   1.5  3.0  4.5  6.0\n -1.5   0.0   1.5   3.0  4.5  6.0  7.5\n  0.0   1.5   3.0   4.5  6.0  7.5  9.0\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.linearphase-Union{Tuple{T}, Tuple{Vector{T}, Tilt}} where T<:(AbstractVector)","page":"API","title":"PhaseUtils.linearphase","text":"linearphase(axes::Vector{<:AbstractVector}, t::Tilt)\n\nEvaluate the tilt t on explicit coordinate axes (one vector per dimension).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.mask2ap-Tuple{Any}","page":"API","title":"PhaseUtils.mask2ap","text":"mask2ap(mask)\n\nConverts  mask array where points outside the aperture are defines as NaN to a Float array, so that NaN -> 0, not NaN -> 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.materialize-Tuple{Tilt, Any}","page":"API","title":"PhaseUtils.materialize","text":"materialize(t::Tilt, dims)\n\nBuild a dense array evaluating the tilt on a grid defined by dims using Fourier-domain coordinates fftshift(fftfreq(d)) for each dimension d. The result has size dims.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.materialize-Tuple{Tilt, Vector{T} where T<:(AbstractVector)}","page":"API","title":"PhaseUtils.materialize","text":"materialize(t::Tilt, axes::Vector{<:AbstractVector})\n\nBuild a dense array evaluating the tilt over the provided coordinate axes, one vector per dimension. This is useful with axis policies such as FourierAxes(), DataAxes(), or DataAxesCentered().\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.membrane_sor!-Tuple{Any, Array, Matrix{Bool}}","page":"API","title":"PhaseUtils.membrane_sor!","text":"membrane_sor!(u, f::Array{Real}, mask_internal::Array{Bool})\n\nSolves Poisson equation Δ u = f, with boundary conditions set by u(x) for x ∉ mask_internal using Successive Overrelaxation method (see Numerical Recipes, ch.20.5.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.membrane_sor-Tuple{Array, Matrix{Bool}}","page":"API","title":"PhaseUtils.membrane_sor","text":"membrane_sor(f::Array{Real}, mask_internal::Array{Bool})\n\nSolves Poisson equation Δ u = f, with boundary conditions u(x) = 0 <=> x ∉ mask_internal using Successive Overrelaxation method (see Numerical Recipes, ch.20.5.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.phwrap-Tuple{Number}","page":"API","title":"PhaseUtils.phwrap","text":"phwrap(ϕ)\n\nWrap phase ϕ: ψ = phwrap(ϕ) ⇔ ψ = ϕ + 2πk, k∈Z, -π <ψ ≤π. If called on an array, works pointwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.setall!-Tuple{Tilt, Any}","page":"API","title":"PhaseUtils.setall!","text":"setall!(t::Tilt, v)\n\nSet the full coefficient vector [σ, τ...] in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.setsigma!-Tuple{Tilt, Any}","page":"API","title":"PhaseUtils.setsigma!","text":"setsigma!(t::Tilt, s)\n\nSet the constant term σ in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.settau!-Tuple{Tilt, Any}","page":"API","title":"PhaseUtils.settau!","text":"settau!(t::Tilt, τ)\n\nSet the slope vector τ in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.sigma-Tuple{Tilt}","page":"API","title":"PhaseUtils.sigma","text":"sigma(t::Tilt)\n\nReturn the constant term σ of a tilt.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.tau-Tuple{Tilt, Any}","page":"API","title":"PhaseUtils.tau","text":"tau(t::Tilt, j)\n\nReturn the j-th component of the slope vector τ.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.tau-Tuple{Tilt}","page":"API","title":"PhaseUtils.tau","text":"tau(t::Tilt)\n\nReturn the slope vector τ of a tilt.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.toArray-Union{Tuple{T}, Tuple{Array{T}, Any}} where T<:CartesianIndex","page":"API","title":"PhaseUtils.toArray","text":"toArray(ind<:Array{CartesianIndex}, vals; crop = true, shift=0, defaultel = 0) --> A\n\nConstruct an array A for which A[ind[i]] = val[i]. If crop is true, return only the minimal bounding box of A. shifted to shift pixels.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhaseUtils.unwrap","page":"API","title":"PhaseUtils.unwrap","text":"unwrap(phase, aperture, method = LS(); restore_piston=false)\n\nUnwrap 2D phase defined inside aperture using method. The values outside the aperture are ignored. If the aperture argument is omitted, it is calucalated automatically from the values of phase array: every pixel with not NaN or missing value is considered to be inside the aperture.\n\nMethods\n\nLS(decomposition, integration): uses  the least-squares decomposition of the wrapped gradient of the wrapped phase in the rotor-free and solenodial fields and integration of the rotor-free part.  By default:\nTalmi-Ribak for decompositon\nF1F2 for integration\n\n\n\n\n\n","category":"function"},{"location":"api/#PhaseUtils.unwrap_LS-Tuple{Any, Any}","page":"API","title":"PhaseUtils.unwrap_LS","text":"unwrap_LS(phase, aperture; restore_piston=true)\n\nUnwrap 2D phase defined inside aperture using the Least-Squares decomposition of the wrapped gradient of the wprapped phase in the rotor-free and solenodial field and integration of the rotor-free part.\n\nIf the restore_piston argument is true, the piston term is added to the unwrapped phase so it the mean of the wrapped difference between the unwrapped phase and the original phase is zero inside the aperture.\n\n\n\n\n\n","category":"method"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")","category":"page"},{"location":"examples/Poisson/#Solving-Poisson-equation","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"","category":"section"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Use membrane_sor(f, a) to calculate the solution of the Poisson equation with zero boundary conditions","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"beginaligned\nDelta u(x) =  f(x) quad x in Ω\nu(x) =   0 quad  x in partial Ω\nendaligned","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Region Ω is defined by the boolean array a, which should have the same dimensions as the source array f.","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Let us simulate a response of a membrane deformable mirror using the Poisson equation. Define a circular aperture of 145-pixel radius and a circular actuator  of 10-pixel radius inside it:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"mask = circlemask((300, 300), 150, 150, 145)\nact = circlemask((300, 300), 50, 153.5, 10);\nnothing #hide","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Plot actuator inside the aperture:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"heatmap(mask .+ act; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Calculate the response and show the results","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"resp = membrane_sor(act, mask)\ncontourf(resp; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Check that the Laplacian of the calculated response is proportional to the actuator shape:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"act_restored = PhaseUtils._calculate_Laplacian(resp)\nheatmap(act_restored .* mask; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"To set the non-zero boundary conditions, use the mutating version of the solver:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"maskrect = zeros(Bool, 300, 300)\nmaskrect[2:(end - 1), 2:(end - 1)] .= true\nu = zeros(size(mask))\nu[1, :] .= 1\nu[end, 100:200] .= -1\nmembrane_sor!(u, zeros(size(u)), maskrect)\nfig, ax, hm = heatmap(u; axis=(aspect=DataAspect(),))\ncontour!(u; labels=true, levels=-1:0.1:1, labelsize=15, color=:black)\nfig","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Next example sets the boundary values for a circular aperture","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"edge_out, _ = find_cw_border(mask; outside=true)\nu = zeros(size(mask))\nu[edge_out] .= sin.(range(0, 4 * 2π, length(edge_out) + 1)[1:(end - 1)])\nheatmap(u; axis=(aspect=DataAspect(),))\n\nmembrane_sor!(u, zeros(size(u)), mask; maxits=1000)\nfig, ax, hm = heatmap(u .* ap2mask(mask); axis=(aspect=DataAspect(),))\ncontour!(u; labels=true, levels=-0.9:0.1:0.9, labelsize=15, color=:white)\nfig","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Unwrapping_method/#Phase-Unwrapping-method-explained","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"The method used in this package is based on the Least-Squares integration of the (maybe inconsistent) gradient fields defined in some connected region.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"The method is based on a fact for phases satisfying Itoh's condition, that is with phase jumps between two adjacent pixels less than π, the wrapped gradient of the wrapped phase is equal to the true phase gradient. Thus, to unwrap a wrapped noisy phase, one proceeds as follows:","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Calculate the gradient of the wrapped phase\nWrap the result. The obtained vector field might be not integratable, so we shall call it quasi-gradient.\nDecompose the quasi-gradient into two orthogonal components, the consistent, rotor-free gradient field, and the solenoidal field.\nIntegrated the consistent gradient field to obtain the unwrapped phase.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")","category":"page"},{"location":"examples/Unwrapping_method/#First-we-define-several-helper-functions.","page":"Phase Unwrapping method  explained","title":"First we define several helper functions.","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"hmap(args...; kwargs...) =\n    heatmap(args...; kwargs..., axis=merge((aspect=DataAspect(),), get(kwargs, :axis, (;))))\n\nfunction residuepixel(center=[0, 0], s=(400, 400))\n    x, y = 1:s[1], 1:s[2]\n    return [atan(yp - center[2], xp - center[1]) for xp in x, yp in y]\nend\n\nfunction resphasepixel(ap, ppos, pneg)\n    s = size(ap)\n    ph = zeros(s)\n    for p in ppos\n        ph .+= residuepixel(p, s)\n    end\n    for p in pneg\n        ph .-= residuepixel(p, s)\n    end\n    return phwrap(ph)\nend\n\nfunction show_grad(gr, label)\n    fig = Figure()\n    ax = CairoMakie.Axis(fig[1, 1]; aspect=DataAspect())\n    hm = heatmap!(ax, gr[1])\n    ax.title = \"First component of the gradient $label\"\n    Colorbar(fig[1, 2], hm)\n    ax = CairoMakie.Axis(fig[1, 3]; aspect=DataAspect())\n    hm = heatmap!(ax, gr[2])\n    Colorbar(fig[1, 4], hm)\n    ax.title = \"Second component of the gradient $label\"\n    rowsize!(fig.layout, 1, Aspect(1, 1.0))\n    resize_to_layout!(fig)\n    return fig\n\nend\n\nfunction show_res!(ax, posx, posy, resmap)\n    respos = resmap .> 0\n    resneg = resmap .< 0\n    scatter!(ax, posx[respos], posy[respos]; color=\"white\", markersize=10)\n    return scatter!(ax, posx[resneg], posy[resneg]; color=\"black\", markersize=10)\nend\n\n\nfunction dual_region_box(ap)\n    dualap = zeros(Bool, size(ap) .+ 1) # index i,j corresponds to the point i-1/2,j-1/2\n    for ind in eachindex(IndexCartesian(), dualap[2:(end - 1), 2:(end - 1)])\n        dualap[ind] =\n            ap[ind] &&\n            ap[ind - CartesianIndex(1, 1)] &&\n            ap[ind - CartesianIndex(1, 0)] &&\n            ap[ind - CartesianIndex(0, 1)]\n    end\n    return dualap\nend\n\nfunction dualcoordmin(ind)\n    return ind.I .- 0.5\nend\nfunction dualcoordplus(ind)\n    return ind.I .+ 0.5\nend\nfunction dualcoordplus(x, y)\n    return CartesianIndex(Int(x + 0.5), Int(y + 0.5))\nend","category":"page"},{"location":"examples/Unwrapping_method/#Generate-a-test-wrapped-phase","page":"Phase Unwrapping method  explained","title":"Generate a test wrapped phase","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"We will do everything on a small resolution example phase.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"n = 8\nap = circlemask((2n, 2n + 1), n, n + 1, n - 2)\nmask = ap2mask(ap)\nhmap(ap)","category":"page"},{"location":"examples/Unwrapping_method/#(Wrapped)-gradient-calculation","page":"Phase Unwrapping method  explained","title":"(Wrapped) gradient calculation","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Choose FiniteDifferences as the default method for gradients etc","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"diffmeth = PhaseUtils.FiniteDifferences()\nget_grad(arr) = PhaseUtils._calculate_gradient(arr, diffmeth)","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Create a test phase with a residue","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phgt = linearphase(size(ap), 0, 0, 0.2, 0.7)\nph = phgt + resphasepixel(ap, [(n + 0.5, n + 1.5)], [])\nphm = ph .* mask\nhmap(ph; axis=(title=\"Original phase, not masked\",)) |> display\nhmap(phm; axis=(title=\"Original phase, masked\",)) |> display","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Calculate gradient of the masked phase","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"gr = get_grad(phm)\nshow_grad(gr, \"\\nof the original phase\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"and wrapped gradient","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"g = (g1, g2) = phwrap.(gr)\nshow_grad(g, \"\\nwrapped\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Find the residues in the phase","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"posx, posy, resmap = getresmapsparce(phm)\n\nshow_res!(posx, posy, resmap) = show_res!(current_axis(), posx, posy, resmap)\nfig, ax, hm = hmap(phm)\nshow_res!(posx, posy, resmap)\nax.title = \"$(length(resmap)) residue(s) found\"\nfig","category":"page"},{"location":"examples/Unwrapping_method/#Decomposition-of-the-quasi-gradient-field-using-Talmi-Ribak-method","page":"Phase Unwrapping method  explained","title":"Decomposition of the quasi-gradient field using Talmi-Ribak method","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"The Talmi-Ribak method is based on the calculation of the correction potential –- a minimal norm field that has the same residues as the quasi-gradient field.","category":"page"},{"location":"examples/Unwrapping_method/#Build-and-solve-the-Poisson-equation-for-the-correction-potential","page":"Phase Unwrapping method  explained","title":"Build and solve the Poisson equation for the correction potential","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"dualap = dual_region_box(ap)\ndualap_inside = copy(dualap)\n\n\n\nrho = zeros(size(dualap_inside))\nfor ind in eachindex(resmap)\n    rho[dualcoordplus(posx[ind], posy[ind])] = π / 2 * resmap[ind]\nend\nfig, ax, hm = hmap(rho);\nheatmap!(ax, ap2mask(1 .- dualap_inside); colormap=:blues)\nax.title = \"region and residues on the dual grid\"\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"corr_pot = membrane_sor(rho, dualap_inside)\nfig, ax, hm = hmap(corr_pot .* ap2mask(dualap));\nax.title = \"Correcting potential\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Calculate the gradient of the correction potential and convert it to the correction field","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"mincy, cx = get_grad(corr_pot)\nshow_grad((mincy, cx), \"\\ncorrection pot-l\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"The correction filed is formed by swapping the components","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"show_grad((-cx[2:(end - 1), :], mincy[:, 2:(end - 1)]), \"\\ncorrector\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Now we can subtract them","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phix = g1 + cx[2:(end - 1), :]\nphiy = g2 - mincy[:, 2:(end - 1)]\nshow_grad((phix, phiy), \"\\nCorrected phase\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"The corrected field should be integratable, which we can check by computing the cross-derivatives","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"dxx, dxy = get_grad(phix)\ndyx, dyy = get_grad(phiy)\nfig, ax, hm = hmap(dxy - dyx);\nax.title = \"mixed derivative after correction\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/#Integration-of-the-consistent-gradient-field-in-the-aperture","page":"Phase Unwrapping method  explained","title":"Integration of the consistent gradient field in the aperture","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"For the integration of a consistent gradient defined inside some aperture, the integration operator should be compatible with the differentiation operator.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Here, we use a simple method of","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"We start by integrating the corrected gradients along the aperture contour","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"cont, apedge = find_cw_border(ap)\nci2Point(ci) = Point(ci.I)\nedgepos = ci2Point.(cont)\nedgedirs = ci2Point.(circshift(cont, -1) .- cont)\n\nfunction integrate_along_path(path, gr, x0=0)\n    ret = zeros(length(path))\n    ret[1] = x0\n    dirs = circshift(path, -1) .- path\n    for i in 1:(length(path) - 1)\n        grad_ind = minimum(path[i:(i + 1)])\n        grad = getindex.(gr, Ref(grad_ind))\n        dir = [dirs[i].I...]\n        important = dir .!= 0\n        delta = dir[important]' * grad[important] # to avoid 0 * NaN\n        ret[i + 1] = ret[i] + delta\n    end\n    return ret\nend\n\nfunction integrate_along_path_cyclic(path, gr)\n    dirs = circshift(path, -1) .- path\n    deltas = zeros(length(path))\n    for i in 1:(length(path))\n        j = mod1(i + 1, length(path))\n        grad_ind = minimum(path[[i, j]])\n        grad = getindex.(gr, Ref(grad_ind))\n        dir = [dirs[i].I...]\n        important = dir .!= 0\n        deltas[i] = dir[important]' * grad[important] # to avoid 0 * NaN\n    end\n    ret = integrate_periodic_grad(deltas)\n    return ret\nend\n\n\n# edgeval = integrate_along_path(cont, [phix, phiy], ph[cont[1]])\nedgeval = integrate_along_path_cyclic(cont, [phix, phiy])\n\nlims = extrema(edgeval)\n\nfig, ax, hm = hmap(phm; colorrange=lims);\narrows!(edgepos, 0.5edgedirs; color=:white)\nscatterlines!(edgepos; color=:white)\nax.title = \"GT phase and aperture contour\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"scatter!(edgepos; color=edgeval, markersize=7.5, colorrange=lims)\nax.title = \"GT phase and unwrapped phase on the aperture contour\"\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Now let's replace in the gradients all elements corresponding to the \"left\" edge (that is [0,-1] orientation) with the values of the restored aperture","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"scatter!(ci2Point.(apedge[:left]) .- Ref([0, 0.3]); marker='↓', color=:red)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"These points we want to update","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"ind = apedge[:left] .+ Ref(CartesianIndex(0, -1))\n\nfig, ax, hm = hmap(phiy)\nscatter!(ci2Point.(ind); marker='O', color=:red)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Create dictionary to make replacement easier","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"edgedict = Dict(zip(cont, edgeval))\n\nphiy[ind] .= getindex.(Ref(edgedict), apedge[:left])","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Repeat for the right edge, but with sign -1","category":"page"},{"location":"examples/Unwrapping_method/#These-points-we-want-to-update","page":"Phase Unwrapping method  explained","title":"These points we want to update","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"ind = apedge[:right] .+ Ref(CartesianIndex(0, 0))\n\nfig, ax, hm = hmap(phiy)\nscatter!(ci2Point.(ind); marker='O', color=:red)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phiy[ind] .= -getindex.(Ref(edgedict), apedge[:right])","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"And for the up and down edges","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"ind = apedge[:up] .+ Ref(CartesianIndex(-1, 0))\n\nfig, ax, hm = hmap(phix)\nscatter!(ci2Point.(ind); marker='O', color=:red)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phix[ind] .= getindex.(Ref(edgedict), apedge[:up])\n\nind = apedge[:down]\n\nfig, ax, hm = hmap(phix)\nscatter!(ci2Point.(ind); marker='O', color=:red)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phix[ind] .= -getindex.(Ref(edgedict), apedge[:down])","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Replace the rest with zeroes, and we can integrate","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phix[isnan.(phix)] .= 0\nphiy[isnan.(phiy)] .= 0\nshow_grad((phix, phiy), \"\\nCorrected for integration\")","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"We'll inegrate using Finite difference cyclic, for this we need to append (prepend?) a raw and a column of zeroes phixcirc = vcat(zeros(size(ph, 1))', phix) phiycirc = hcat(zeros(size(ph, 1)), phiy)","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phixcirc = vcat(phix, zeros(size(ph, 2))')\nphiycirc = hcat(phiy, zeros(size(ph, 1)))\n\nshow_grad((phixcirc, phiycirc), \"\\nCorrected for integration\")","category":"page"},{"location":"examples/Unwrapping_method/#Integration-by-summation","page":"Phase Unwrapping method  explained","title":"Integration by summation","text":"","category":"section"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Now, we can intagrate simply by summation. The corrected gradient field should have zero residues.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"gradres = PhaseUtils.getresmap(phixcirc, phiycirc)\nfig, ax, hm = hmap(gradres);\nax.title = \"Divergence of the corrected field\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"ph_sum = circshift(reshape(cumsum(phixcirc[:]), size(ph)), 1)\nfig, ax, hm = hmap(ph_sum)\nax.title = \"Restored  by direct summation phase\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"And we can calcualte the rotational component","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"rot_comp = phwrap(phm - ph_sum)\nfig, ax, hm = hmap(rot_comp .* mask)\nax.title = \"Rotational component\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Restore with LS integration.","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phi = circshift(\n    integrate_2dgrad(phixcirc, phiycirc, PhaseUtils.FiniteDifferencesCyclic()), (0, 0)\n)\nfig, ax, hm = hmap(phi)\nax.title = \"Restored phase with LS method\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"Now the region outside the boundary is  flat","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"fig, ax, hm = hmap(phi .* mask)\nax.title = \"Restored phase with LS method\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"This method is now realized as _unwrap_LS_Poisson and is called by default by unwrap_LS","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"phm_un = unwrap_LS(phm, ap; restore_piston=true)\nfig, ax, hm = hmap(phm_un .* mask);\nax.title = \"Restored phase with PhaseUtils method\"\nColorbar(fig[1, 2], hm)\nfig","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"","category":"page"},{"location":"examples/Unwrapping_method/","page":"Phase Unwrapping method  explained","title":"Phase Unwrapping method  explained","text":"This page was generated using Literate.jl.","category":"page"},{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package contains small utilities used often in Phase-Retrieval-related context.","category":"page"},{"location":"examples/contour_unwrappin_tmp/","page":"Temporary file, for test/debug purposes","title":"Temporary file, for test/debug purposes","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")\nphasedisplay(args...; kwargs...) = heatmap(\n    args...;\n    axis=(aspect=DataAspect(),),\n    colormap=:cyclic_mygbm_30_95_c78_n256,\n    kwargs...,\n)\narraydisplay(args...; kwargs...) = heatmap(args...; axis=(aspect=DataAspect(),), kwargs...)","category":"page"},{"location":"examples/contour_unwrappin_tmp/#Temporary-file,-for-test/debug-purposes","page":"Temporary file, for test/debug purposes","title":"Temporary file, for test/debug purposes","text":"","category":"section"},{"location":"examples/contour_unwrappin_tmp/#Example-with-circular-aperture-(for-tests)","page":"Temporary file, for test/debug purposes","title":"Example with circular aperture (for tests)","text":"","category":"section"},{"location":"examples/contour_unwrappin_tmp/","page":"Temporary file, for test/debug purposes","title":"Temporary file, for test/debug purposes","text":"s1, s2, m = 140, 100, 25\nap = zeros(s1, s2)\ny = range(-1.1 * s1 / s2, 1.1 * s1 / s2, s1)\nx = range(-1.1, 1.1, s2)\nap[[x .^ 2 + y .^ 2 .<= 1 for y in y, x in x]] .= 1\nphaseGT = [-x^3 + 3x .^ 2 + y .^ 2 - 10y for y in y, x in x]\nphaseGT .-= sum(phaseGT .* ap) / sum(ap) #extract mean\nphase = phwrap(phaseGT) .* ap\nphasedisplay(phase)\n\nsol = unwrap_LS(phase, ap; restore_piston=false)\nsol .-= sum(sol .* ap) / sum(ap) #extract mean\nfig, ax, hm = arraydisplay((sol .- phaseGT) .* ap2mask(ap))\nax.title = \"Phase restoration error is $(maskedrmse(sol, phaseGT, ap)) rms\"\nColorbar(fig[1, 2])\nfig","category":"page"},{"location":"examples/contour_unwrappin_tmp/","page":"Temporary file, for test/debug purposes","title":"Temporary file, for test/debug purposes","text":"","category":"page"},{"location":"examples/contour_unwrappin_tmp/","page":"Temporary file, for test/debug purposes","title":"Temporary file, for test/debug purposes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/tilts_axes/#Tilts-and-Axes-{#guides/tilts_axes}","page":"Tilts and Axes","title":"Tilts and Axes {#guides/tilts_axes}","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"The tilt model is an affine function over coordinates x:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"σ + τ · x","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"It’s stored as a static coefficient vector [σ, τ₁, τ₂, …] for performance and clarity.","category":"page"},{"location":"guides/tilts_axes/#Types","page":"Tilts and Axes","title":"Types","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Tilt — abstract supertype. Coefficients layout [σ, τ…].\nTiltCentered — concrete tilt, convenient for centered frames (e.g., Fourier coords).\nFreeTilt — concrete tilt without centering semantics.","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Axis policies define coordinates per dimension:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"ArrayAxes — abstract supertype\nFourierAxes() — uses fftshift(fftfreq(d)) per dimension\nDataAxes() — uses 1:d per dimension\nDataAxesCentered() — uses fftshift(fftfreq(d, d)) per dimension","category":"page"},{"location":"guides/tilts_axes/#Basic-usage","page":"Tilts and Axes","title":"Basic usage","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"using PhaseUtils\n\n# a 2D tilt: [σ, τx, τy]\nt = TiltCentered([0.1, 0.2, -0.3])\n\n# Fourier-domain axes for a 6×5 grid\nax = FourierAxes()((6, 5))\n\n# Evaluate on provided axes\nA = materialize(t, ax)\n@assert size(A) == (6, 5)\n\n# Apply to a single point (x, y)\nval = apply(t, (0.5, -0.5))","category":"page"},{"location":"guides/tilts_axes/#Choosing-axes","page":"Tilts and Axes","title":"Choosing axes","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Use FourierAxes() when τ is defined in frequency units matching FFT conventions.\nUse DataAxes() when τ is in pixel-index units (1-based).\nUse DataAxesCentered() for integer-like centered coordinates (spatial domain centered at zero).","category":"page"},{"location":"guides/tilts_axes/#Mutating-coefficients","page":"Tilts and Axes","title":"Mutating coefficients","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"using PhaseUtils\n\nc = TiltCentered([0.0, 1.0, 2.0])\nsetsigma!(c, 1.5)\nsettau!(c, [-2.0, 3.0])\nsetall!(c, [0.1, 0.2, 0.3])","category":"page"},{"location":"guides/tilts_axes/#API","page":"Tilts and Axes","title":"API","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"See: @ref api for the full reference.","category":"page"},{"location":"guides/tilts_axes/#Examples:-circle-masks-in-different-axes","page":"Tilts and Axes","title":"Examples: circle masks in different axes","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Below we generate circle masks in three coordinate systems for a 100×200 grid and visualize them. In Fourier axes, coordinates span [-0.5, 0.5) in normalized frequency units (from −Nyquist to +Nyquist). A radius of 0.25 corresponds to half-Nyquist. The matrix with Fourier axes is shown with a fixed aspect ratio.","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"using PhaseUtils, CairoMakie\n\ndims = (100, 200)\n\n# Fourier axes: normalized frequency in [-0.5, 0.5)\nmask_fourier = circlemask(dims, 0.25, FourierAxes())\n\n# Data axes: 1-based indices, choose radius in pixels; center at (dims+1)/2 by default\nradius_px = 32\nmask_data = circlemask(dims, (dims[1]+1)/2, (dims[2]+1)/2, radius_px, DataAxes())\n\n# Centered data axes: integer-like coordinates centered at zero (e.g., radius 32)\nmask_centered = circlemask(dims, 32, DataAxesCentered())\n\nf = Figure(resolution=(900, 300))\nax1 = Axis(f[1, 1], title=\"FourierAxes(): r=0.25 (half-Nyquist)\", aspect = AxisAspect(1))\nax2 = Axis(f[1, 2], title=\"DataAxes(): r=32 px\", aspect = DataAspect())\nax3 = Axis(f[1, 3], title=\"DataAxesCentered(): r=32\", aspect = DataAspect())\nheatmap!(ax1, FourierAxes()(mask_fourier)..., mask_fourier)\nheatmap!(ax2, DataAxes()(mask_data)..., mask_data)\nheatmap!(ax3, DataAxesCentered()(mask_centered)..., mask_centered)\n\nassetdir = joinpath(@__DIR__, \"..\", \"assets\")\nmkpath(assetdir)\nsave(joinpath(assetdir, \"circle_masks_axes.png\"), f)\nf","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"The saved image will appear below if built with CairoMakie:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"(Image: Circle masks in different axes)","category":"page"},{"location":"guides/tilts_axes/#Mutating-example:-materialize-a-tilt-and-mask-a-circle","page":"Tilts and Axes","title":"Mutating example: materialize a tilt and mask a circle","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"This example creates a tilt, materializes it on Fourier axes, and masks (zeros) values outside a circular region of radius 0.25 (half-Nyquist):","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"using PhaseUtils, CairoMakie\n\ndims = (100, 200)\nt = TiltCentered([0.1, 0.3, -0.2])\nA = materialize(t, FourierAxes()(dims))\nB = copy(A)\ncirclemask!(B, 0.25, FourierAxes())\n\nf = Figure(resolution=(600, 300))\nax1 = Axis(f[1, 1], title=\"Tilt (Fourier axes)\", subtitle = \"size(A) = $(size(A))\", aspect = AxisAspect(1))\nax2 = Axis(f[1, 2], title=\"Masked outside r=0.25\", aspect = AxisAspect(1))\nheatmap!(ax1, FourierAxes()(A)..., A)\nheatmap!(ax2, FourierAxes()(B)..., B)\n\nf","category":"page"},{"location":"guides/tilts_axes/#Using-explicit-ranges-with-ProvidedAxes","page":"Tilts and Axes","title":"Using explicit ranges with ProvidedAxes","text":"","category":"section"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"ProvidedAxes lets you bind arbitrary (possibly non-uniform) coordinate ranges. Ranges in Julia (e.g. -1:0.1:1) are AbstractRanges and already behave like vectors for indexing and broadcasting.","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Basic 2D example with symmetric ranges at custom spacing:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"using PhaseUtils\n\nxr = -1:0.1:1            # 21 points\nyr = -0.5:0.05:0.5       # 21 points (different physical span / step)\npax = ProvidedAxes(xr, yr)\n\n# Create a tilt with piston 0.0 and slopes 0.4 (x), -0.2 (y)\nt = TiltCentered([0.0, 0.4, -0.2])\nA = materialize(t, pax((length(xr), length(yr))))\nsize(A), A[1,1], A[end,end]","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"Non-uniform grids (e.g. quadratic spacing) work the same:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"xr2 = collect(range(-1, 1; length=64).^2 .* sign.(range(-1, 1; length=64))) # denser near zero\nyr2 = range(-2, 2; length=48)\npax2 = ProvidedAxes(xr2, yr2)\nt2 = TiltCentered([0.1, 0.05, 0.01])\nB = materialize(t2, pax2((length(xr2), length(yr2))))\nextrema(B)","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"If the requested dims mismatch the stored axes lengths an error is thrown:","category":"page"},{"location":"guides/tilts_axes/","page":"Tilts and Axes","title":"Tilts and Axes","text":"try\n\tpax((22, 21))  # xr has length 21 → mismatch\ncatch err\n\tprintln(\"Caught error: \", err.msg)\nend\nnothing","category":"page"},{"location":"examples/contours_detection/#Test-of-the-contour-detection","page":"Test of the contour detection","title":"Test of the contour detection","text":"","category":"section"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"I use simple contour detection for phase unwrapping. The goal is to find the points where the finite difference is not defined.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Begin with a circular aperture.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")\narraydisplay(args...; kwargs...) = heatmap(args...; axis=(aspect=DataAspect(),), kwargs...)\n\nap = circlemask((30, 20), 10, 10, 8)\nfig, ax, hm = arraydisplay(ap; colormap=:reds, alpha=0.25)\nedg = PhaseUtils._find_set_edges(ap)\nfor k in keys(edg)\n    scatter!(\n        map(x -> Tuple(x) .+ Tuple(PhaseUtils.step[k]) .* 0.2, edg[k]); label=\"$(String(k))\"\n    )\nend\nleg = axislegend(ax)\nax.title = \"Detected edge pixels for inner circle\"\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"We can now sort all these pixels in a clockwise manner","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"cwborder, _ = PhaseUtils._find_cw_border_alloc(ap)\nscatter!(map(Tuple, cwborder); marker='o', color=:black, label=\"Contour\")\ndelete!(leg)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Now check the same for the inverse mask","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"notap = .!ap\nfig, ax, hm = arraydisplay(notap; colormap=:reds, alpha=0.25)\nedg = PhaseUtils._find_set_edges(notap)\nfor k in keys(edg)\n    scatter!(\n        map(x -> Tuple(x) .+ Tuple(PhaseUtils.step[k]) .* 0.2, edg[k]); label=\"$(String(k))\"\n    )\nend\nleg = axislegend(ax)\nax.title = \"Detected edge pixels for outer circle\"\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"We can now sort all these pixels in a clockwise manner","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"cwborder, _ = PhaseUtils._find_cw_border_alloc(ap; outside=true)\nscatter!(map(Tuple, cwborder); marker='o', color=:black, label=\"Contour\")\ndelete!(leg)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/contours_detection/#More-difficult-shapes","page":"Test of the contour detection","title":"More difficult shapes","text":"","category":"section"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"ap = circlemask((40, 22), 10, 11, 8) .|| circlemask((40, 22), 26, 11, 9)\nfig, ax, hm = arraydisplay(ap; colormap=:reds, alpha=0.25)\nedg = PhaseUtils._find_set_edges(ap)\nfor k in keys(edg)\n    scatter!(\n        map(x -> Tuple(x) .+ Tuple(PhaseUtils.step[k]) .* 0.2, edg[k]); label=\"$(String(k))\"\n    )\nend\nleg = axislegend(ax)\nax.title = \"Detected edge pixels for inner edge\"\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"We can now sort all this pixels in a clockwise manner","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"cwborder, _ = PhaseUtils._find_cw_border_alloc(ap)\nscatter!(map(Tuple, cwborder); marker='o', color=:black, label=\"Contour\")\ndelete!(leg)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Now check the same for the inverse mask","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"notap = .!ap\nfig, ax, hm = arraydisplay(notap; colormap=:reds, alpha=0.25)\nedg = PhaseUtils._find_set_edges(notap)\nfor k in keys(edg)\n    scatter!(\n        map(x -> Tuple(x) .+ Tuple(PhaseUtils.step[k]) .* 0.2, edg[k]); label=\"$(String(k))\"\n    )\nend\nleg = axislegend(ax)\nax.title = \"Detected edge pixels for outer edge\"\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"We can now sort all these pixels in a clockwise manner","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"cwborder, _ = PhaseUtils._find_cw_border_alloc(ap; outside=true)\nscatter!(map(Tuple, cwborder); marker='o', color=:black, label=\"Contour\")\ndelete!(leg)\naxislegend(ax)\nfig","category":"page"},{"location":"examples/contours_detection/#Conclusions","page":"Test of the contour detection","title":"Conclusions","text":"","category":"section"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"It works as expected.","category":"page"},{"location":"examples/contours_detection/#Dual-and-half-dual-grids","page":"Test of the contour detection","title":"Dual and half-dual grids","text":"","category":"section"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"For Talmi-Ribak's method, I also need to find points on the dual grid that fall within the area and on its boundary (with at least two adjacent pixels). Here is a straightforward approach.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"function dual_region(ap)\n    dualap = zeros(Bool, size(ap) .+ 1) # index i,j corresponds to the point i-1/2,j-1/2\n    for ind in eachindex(IndexCartesian(), ap)\n        if ap[ind]\n            if ap[ind + CartesianIndex(1, 0)] #two horisontal neighbours (i,j) and (i+1,j)\n                dualap[ind + CartesianIndex(1, 0)] = 1 # (i+1/2,j-1/2)\n                dualap[ind + CartesianIndex(1, 1)] = 1 # (i+1/2,j+1/2)\n            end\n            if ap[ind + CartesianIndex(0, 1)] #two vertical neighbours (i,j) and (i,j+1)\n                dualap[ind + CartesianIndex(0, 1)] = 1 # (i-1/2,j+1/2)\n                dualap[ind + CartesianIndex(1, 1)] = 1 # (i+1/2,j+1/2)\n            end\n        end\n    end\n    return dualap\nend\n\nfunction dualcoordmin(ind)\n    return ind.I .- 0.5\nend\nfunction dualcoordplus(ind)\n    return ind.I .+ 0.5\nend","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Plot the ap and its dual region.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"fig, ax, hm = arraydisplay(ap; colormap=:reds, alpha=0.25);\ndualap = dual_region(ap)\ncwborder, _ = PhaseUtils._find_cw_border_alloc(dualap)\nscatter!(dualcoordmin.(findall(dualap)); marker='+', color=:blue, label=\"dual region\")\nscatter!(map(dualcoordmin, cwborder); color=:blue, marker='□', label=\"dual contour\")\nleg = axislegend(ax)\nax.title = \"Detected dual region and its border\"\nfig","category":"page"},{"location":"examples/contours_detection/#Alternative-approach","page":"Test of the contour detection","title":"Alternative approach","text":"","category":"section"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Alternative approach would be to look where the residue can be defined, and this mean all 4 pixels surroundg the dual vertex should be in the aperture. This is equivalent to covolution  with a  box 2x2.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"function dual_region_box(ap)\n    dualap = zeros(Bool, size(ap) .+ 1) # index i,j corresponds to the point i-1/2,j-1/2\n    for ind in eachindex(IndexCartesian(), dualap[2:(end - 1), 2:(end - 1)])\n        dualap[ind] =\n            ap[ind] &&\n            ap[ind - CartesianIndex(1, 1)] &&\n            ap[ind - CartesianIndex(1, 0)] &&\n            ap[ind - CartesianIndex(0, 1)]\n    end\n    return dualap\nend","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"Plot the ap and its dual region.","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"fig, ax, hm = arraydisplay(ap; colormap=:reds, alpha=0.25);\ndualap = dual_region_box(ap)\ncwborder, _ = PhaseUtils._find_cw_border_alloc(dualap; outside=true)\nscatter!(dualcoordmin.(findall(dualap)); marker='+', color=:blue, label=\"dual region\")\nscatter!(map(dualcoordmin, cwborder); color=:blue, marker='□', label=\"dual contour\")\nleg = axislegend(ax)\nax.title = \"Detected dual region and its border\"\nfig","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"","category":"page"},{"location":"examples/contours_detection/","page":"Test of the contour detection","title":"Test of the contour detection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#PhaseUtils.jl","page":"Home","title":"PhaseUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Utilities for phase retrieval workflows. This documentation covers core helpers and shared data structures.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using PhaseUtils\n\n# Define a tilt with coefficients [σ, τ₁, τ₂]\nt = TiltCentered([0.1, 0.2, -0.3])\n\n# Evaluate on a small Fourier grid\nA = materialize(t, (4, 4))\nsize(A)","category":"page"},{"location":"#Learn-more","page":"Home","title":"Learn more","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Guides","category":"page"},{"location":"","page":"Home","title":"Home","text":"- [Tilts and Axes](@ref guides/tilts_axes)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Reference","category":"page"},{"location":"","page":"Home","title":"Home","text":"- [API](@ref api)","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
