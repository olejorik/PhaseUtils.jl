var documenterSearchIndex = {"docs":
[{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"EditURL = \"../../../examples/Poisson.jl\"","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"CurrentModule = PhaseUtils\nDocTestSetup = quote\n    using PhaseUtils\nend","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"using PhaseUtils\nusing CairoMakie\nCairoMakie.activate!(; type=\"png\")","category":"page"},{"location":"examples/Poisson/#Solving-Poisson-equation","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"","category":"section"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Let us simulate a response of a membrane deformable mirror using the Poisson equation. Define a circular aperture of 145-pixel radius and a circular actuator  of 10-pixel radius inside it:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"mask = zeros(300, 300)\nmask = [\n    ((i[1] - 150)^2 + (i[2] - 150)^2 < 145^2) for i in eachindex(IndexCartesian(), mask)\n]\nact = [((i[1] - 120)^2 + (i[2] - 150)^2 < 10^2) for i in eachindex(IndexCartesian(), mask)]","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Plot actuator inside the aperture:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"heatmap(mask .+ act; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Calculate the response and show the results","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"resp = membrane_sor(act, mask)\ncontourf(resp; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"Check that the Laplacian of the calculated response is proportional to the actuator shape:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"act_restored = PhaseUtils._calculate_Laplacian(resp)\nheatmap(act_restored .* mask; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"To set the boundary conditions, use the mutating version of the solver:","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"mask = zeros(Bool, 300, 300)\nmask[2:(end - 1), 2:(end - 1)] .= true\nu = zeros(size(mask))\nu[1, :] .= 1\nmembrane_sor!(u, zeros(size(u)), mask)\nheatmap(u; axis=(aspect=DataAspect(),))","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"","category":"page"},{"location":"examples/Poisson/","page":"Solving Poisson equation","title":"Solving Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"about/#About-the-package","page":"About","title":"About the package","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This package contains small utilities used often in Phase-Retrieval-related context.","category":"page"},{"location":"#PhaseUtils.jl","page":"Home","title":"PhaseUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PhaseUtils.jl","category":"page"},{"location":"#Types-and-Functions","page":"Home","title":"Types and Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [PhaseUtils]\nPrivate = false","category":"page"},{"location":"#PhaseUtils.bboxview","page":"Home","title":"PhaseUtils.bboxview","text":"bboxview(arr, mask, pad = 0)\n\nMake a box corresponding to the mask not-NaN elements surrounded by pad.\n\n\n\n\n\n","category":"function"},{"location":"#PhaseUtils.crop-Tuple{AbstractArray, Any, Any}","page":"Home","title":"PhaseUtils.crop","text":"crop(a::AbstractArray, cropsize[, cropcenter])\ncrop(cropsize[, cropcenter]) creates a cropping operator.\n\nCrop the array to cropsize around cropcenter. If cropcenter is omitted, use central element of the array.\n\ncropsize and cropcenter can be either tuples/vectors of integers or just single integer, which represent a tuple of identical numbers.\n\nExamples\n\njulia> a = reshape(1:15, 3, 5); crop(a, 1, (1, 3))\n1×1 Matrix{Int64}:\n 7\n\njulia> crop(a, (2, 2), (1, 3))\n1×2 Matrix{Int64}:\n 4  7\n\njulia> crop(3)(a)\n3×3 Matrix{Int64}:\n 4  7  10\n 5  8  11\n 6  9  12\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.integrate_2dgrad","page":"Home","title":"PhaseUtils.integrate_2dgrad","text":"integrate_2dgrad(gx, gy[, gradmethod=default_grad_method(gx)])\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"#PhaseUtils.integrate_periodic_grad-Tuple{Any}","page":"Home","title":"PhaseUtils.integrate_periodic_grad","text":"integrate_periodic_grad(g)\n\nIntegrate 1D gradient with periodic boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.itoh-Tuple{Any}","page":"Home","title":"PhaseUtils.itoh","text":"itoh(phi)\n\nItoh's algorithm for 1D phase unwrapping.\n\nExample\n\njulia> ph = 1:10\n1:10\n\njulia> ph_w = phwrap(ph)\n10-element Vector{Float64}:\n  1.0\n  2.0\n  3.0\n -2.2831853071795867\n -1.2831853071795865\n -0.28318530717958645\n  0.7168146928204135\n  1.7168146928204135\n  2.7168146928204133\n -2.566370614359173\n\njulia> itoh(ph_w)\n10-element Vector{Float64}:\n  1.0\n  2.0\n  3.0\n  4.0\n  5.0\n  6.0\n  7.0\n  8.0\n  9.0\n 10.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.membrane_sor!-Tuple{Any, Array, Matrix{Bool}}","page":"Home","title":"PhaseUtils.membrane_sor!","text":"membrane_sor!(u, f::Array{Real}, mask_internal::Array{Bool})\n\nSolves Poisson equation Δ u = f, with boundary conditions set by u(x) for x ∉ mask_internal using Successive Overrelaxation method (see Numerical Recipes (www.cambridge.org/9780521880688), ch.20.5.1).\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.membrane_sor-Tuple{Array, Matrix{Bool}}","page":"Home","title":"PhaseUtils.membrane_sor","text":"membrane_sor(f::Array{Real}, mask_internal::Array{Bool})\n\nSolves Poisson equation Δ u = f, with boundary conditions u(x) = 0 <=> x ∉ mask_internal using Successive Overrelaxation method (see Numerical Recipes (www.cambridge.org/9780521880688), ch.20.5.1).\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.phwrap-Tuple{Number}","page":"Home","title":"PhaseUtils.phwrap","text":"Wrap Phase\n\n\n\n\n\n","category":"method"},{"location":"#PhaseUtils.unwrap_LS-Tuple{Any, Any}","page":"Home","title":"PhaseUtils.unwrap_LS","text":"unwrap_LS(phase, aperture; restore_piston=true)\n\nUnwrap 2D phase defined inside aperture using the Least-Squares decomposition of the wrapped gradient of the wprapped phase in the rotor-free and solenodial field and integration of the rotor-free part.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
